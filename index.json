[{"categories":["开发"],"content":"Wiki Home · acmesh-official/acme.sh Wiki · GitHub 说明 · acmesh-official/acme.sh Wiki · GitHub How to issue a cert · acmesh-official/acme.sh Wiki · GitHub dnsapi · acmesh-official/acme.sh Wiki · GitHub 安装 yum update ca-certificates # centos apt install ca-certificates # debian curl https://get.acme.sh | sh -s email=echo@echo.xyz wget -O - https://get.acme.sh | sh -s email=echo@echo.xyz # 国内使用 # https://github.com/acmesh-official/acme.sh/wiki/Install-in-China git clone https://gitee.com/neilpang/acme.sh.git cd acme.sh ./acme.sh --install -m email=echo@echo.xyz source ~/.bashrc source ~/.zshrc 开启自动更新 acme.sh --upgrade --auto-upgrade acme.sh --upgrade --auto-upgrade 0 # 关闭自动更新 常见命令 acme.sh --help # help acme.sh --list # 列出证书 acme.sh --upgrade # 检查更新 acme.sh --issue # 申请证书 acme.sh --renew # 更新证书 acme.sh --revoke # 吊销证书 acme.sh --remove # 删除证书 acme.sh --install-cert # 安装证书 切换CA # 切换为letsencrypt acme.sh --set-default-ca --server letsencrypt # 切换为zerossl acme.sh --set-default-ca --server zerossl apt-get install socat Server · acmesh-official/acme.sh Wiki · GitHub 证书申请 sh acme.sh --issue -d renalio.eu.org --standalone acme.sh --issue -d rsync.157077.xyz --standalone ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:0:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"HTTP认证 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"使用独立服务模式 如果服务器上没有运行任何 Web 服务，80 端口是空闲的，那么 acme.sh 还能假装自己是一个 WebServer，临时监听 80 端口，完成验证: acme.sh --issue --standalone -d example.com -d www.example.com -d cp.example.com ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:1","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"直接签发(HTTP-01 验证) 需要你的服务器上面已经部署了网站环境。（被申请的域名可以正常被打开） Acme 自动在你的网站根目录下放置一个文件, （这个文件可以被互联网访问）来验证你的域名所有权,完成验证. 然后就可以生成证书了. 只需要指定域名，并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件，并放到网站的根目录，验证完成后会聪明的删除验证文件，整个过程没有任何副作用。 acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/ ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:2","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"TLS-ALPN-01 验证 通过在服务器上使用自定义的 TLS 握手来验证域名的所有权。这种方式适用于没有 Web 服务器的情况。 如果您没有网络服务器，可能您正在 smtp 或 ftp 服务器上， 443 端口是空闲的。您可以使用独立的 TLS ALPN 模式。acme.sh 内置了独立的 TLS 网络服务器，它可以监听 443 端口以颁发证书。 acme.sh --issue -d yourdomain.com --alpn acme.sh --issue -d example.com --alpn --tlsport 8443 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:3","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"使用 Nginx 模式 如果你用的 Nginx 服务器，或者反代，acme.sh 还可以智能的从 Nginx 的配置中自动完成验证，你不需要指定网站根目录: acme.sh --issue --nginx -d example.com -d www.example.com -d cp.example.com ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:4","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"使用 Apache 模式 如果你用的 Apache 服务器，acme.sh 还可以智能的从 Apache 的配置中自动完成验证，你不需要指定网站根目录: acme.sh --issue --apache -d example.com -d www.example.com -d cp.example.com 注意，无论是 Apache 还是 Nginx 模式，acme.sh 在完成验证之后，会恢复到之前的状态，都不会私自更改程序本身的配置. 好处是你不用担心配置被搞坏，也有一个缺点，你需要自己配置 SSL 项，否则只能成功生成证书，你的网站还是无法正常使用 HTTPS。 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:1:5","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"DNS认证 如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:2:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"手动验证 这需要你手动在域名上添加一条 TXT 解析记录，验证域名所有权。 注意，如果使用手动验证，acme.sh 将无法自动更新证书，每次都需要手动添加解析来验证域名所有权。如果有自动更新证书的需求，请使用自动验证（DNS API）。 acme.sh --issue --dns -d example.com -d www.example.com -d cp.example.com 然后，acme.sh 会生成相应的解析记录显示出来，你只需要在你的域名管理面板中添加这条 TXT 记录即可。 等待解析完成之后，执行以下命令重新生成证书： acme.sh --renew -d mydomain.com 注意这里现在用的是 --renew 参数 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:2:1","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"自动验证(DNS API)(DNS-01 验证) DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。 acme.sh 目前支持超过一百家的 DNS API。 以 DNSPod.cn 为例，你需要先登录到 DNSPod.cn，拿到你的 DNSPod API Key 和 ID 并设置： export DP_Id=\"1234\" export DP_Key=\"sADDsdasdgdsf\" 现在我们可以签发通配符证书了： acme.sh --issue --dns dns_dp -d example.com -d *.example.com DP_Id 和 DP_Key 将保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置。 更详细的 DNS API 用法: https://github.com/acmesh-official/acme.sh/wiki/dnsapi 支持的 DNS API 包括但不限于： dns_cf：Cloudflare dns_dp：DNSPod dns_cx：CloudXNS dns_ali：阿里云 DNS dns_aws：AWS Route 53 dns_gd：GoDaddy dns_linode：Linode dns_nsupdate：BIND DNS dns_ovh：OVH dns_pdns：PowerDNS dns_gcore：G-Core Labs Cloudflare示例 请稍候… dnsapi · acmesh-official/acme.sh Wiki · GitHub 使用限制性令牌 多个区域DNS export CF_Account_ID=\"763eac4f1bcebd8b5c95e9fc50d010b4\" export CF_Token=\"Y_jpG9AnfQmuX5Ss9M_qaNab6SQwme3HWXNDzRWs\" 使用全局API密钥 export CF_Key=\"763eac4f1bcebd8b5c95e9fc50d010b4\" export CF_Email=\"alice@example.com\" 查看已安装证书信息 acme.sh --info -d example.com 安装证书 证书生成好以后，我们需要把证书复制给对应的 Apache、Nginx 或其他服务器去使用。 必须使用 --install-cert 命令来把证书复制到目标文件，请勿直接使用 ~/.acme.sh/ 目录下的证书文件，这里面的文件都是内部使用，而且目录结构将来可能会变化。 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:2:2","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"Nginx示例 acme.sh --install-cert -d example.com \\ --key-file /path/to/keyfile/in/nginx/key.pem \\ --fullchain-file /path/to/fullchain/nginx/cert.pem \\ --reloadcmd \"service nginx reload\" 对应的参数： --key-file ：私钥文件安装地址 --cert-file ：证书文件安装地址 --fullchain-file ：证书链文件安装地址 --reloadcmd ：重启命令内容 server { listen 80; listen [::]:80; server_name www.exmaple.com; rewrite ^(.*)$ https://$host$1 permanent; } server { charset utf-8; listen 443 ssl; listen [::]:443; server_name www.exmaple.com; ssl_certificate /etc/nginx/ssl/www.exmaple.com/fullchain.pem; ssl_certificate_key /etc/nginx/ssl/www.exmaple.com/key.pem; location / { # rewrite ^/api-server/(.*)$ /$1 break; proxy_pass http://172.24.64.224:19999/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # location / { # root /usr/share/nginx/html; # index index.html index.htm; # } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:3:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"Apache示例 acme.sh --install-cert -d example.com \\ --cert-file /path/to/certfile/in/apache/cert.pem \\ --key-file /path/to/keyfile/in/apache/key.pem \\ --fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \\ --reloadcmd \"service apache2 force-reload\" 更新证书 目前证书每 60 天自动更新，你无需任何操作。 但是你也可以强制续签证书： acme.sh --renew -d example.com --force 吊销证书 acme.sh --revoke -d dnomd343.top 删除证书 acme.sh --remove -d dnomd343.top 链接🔗 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:4:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"FreeSSL FreeSSL.cn - 一个提供免费HTTPS证书申请的网站 ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:5:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发"],"content":"项目地址 GitHub - acmesh-official/acme.sh: A pure Unix shell script implementing ACME client protocol ","date":"2025-04-24","objectID":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/:6:0","tags":["Acme","SSL"],"title":"ACME证书申请","uri":"/acme%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"},{"categories":["开发","环境配置"],"content":"安装 ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:0:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"安装 zsh sudo apt-get update sudo apt-get upgrade apt-get install git,zsh zsh --version Shell 切换 ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:1:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"切换为 Bash echo $SHELL which bash sudo chsh -s $(which bash) ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:2:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"切换为 zsh echo $SHELL zsh --version which zsh sudo chsh -s $(which zsh) #sudo用于root用户 chsh -s $(which zsh) restart reboot Oh-my-zsh 安装与配置 Oh My Zsh - a delightful \u0026 open source framework for Zsh ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:3:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"安装 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" sh -c \"$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" #国内镜像 sh -c \"$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\" sh -c \"$(wget -O- https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)\" ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:4:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"主题 GitHub - romkatv/powerlevel10k: A Zsh theme git clone --depth=1 https://github.com/romkatv/powerlevel10k.git \"${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\" # 国内镜像 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git \"${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\" # 编写.zshrc ZSH_THEME=\"powerlevel10k/powerlevel10k\" source ~/.zshrc p10k configure ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:5:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"插件 ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:6:0","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"Zsh-syntax-highlighting ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:6:1","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"Zsh-autosuggestions ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:6:2","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["开发","环境配置"],"content":"zsh-completions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone --depth=1 https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-completions zsh-completions plugins=(evalcache git git-extras debian tmux screen history extract colorize web-search docker zsh-completions zsh-autosuggestions zsh-syntax-highlighting) source ~/.zshrc 配置 # ~/.zshrc # proxy func proxy () { export http_proxy=\"http://127.0.0.1:8087\" export https_proxy=\"http://127.0.0.1:8087\" echo \"HTTP Proxy on\" } noproxy () { unset http_proxy unset https_proxy echo \"HTTP Proxy off\" } # end proxy source ~/.zshrc 让 Zsh 终端走代理 | 纸帆|ZevenFang 更新 upgrade_oh_my_zsh 卸载 uninstall_oh_my_zsh 参考链接🔗 zsh 安装与配置，使用 oh-my-zsh 美化终端 | Leehow的小站 使用 Zsh 作为 Ubuntu 的默认 Shell Linux 全局安装配置 zsh + oh-my-zsh - sysin | SYStem INside | 软件与技术分享 ","date":"2025-04-02","objectID":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/:6:3","tags":["Zsh","环境配置"],"title":"ZSH安装与配置","uri":"/zsh%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"},{"categories":["AI"],"content":" 注意 以下将 MCP (主要指服务端) 和 FunctionCall (主要指 OpenAI chat 规范的函数调用) 都笼统称为“插件”，方便快速理解， 模型本身不具备调用 function 或 mcp Server 的能力 两者都是告诉远程模型，客户端具备那些额外能力(如天气插件、数据库插件、画图插件)，模型依据当前上下文 (当前语句)，判断当前场景是否应该执行某几个插件, 以及参数是什么,并返回一个特殊的响应，将结果返回到客户端 模型本身只是返回各种\"文本\" 当客户端(如 CherryStudio、NextChat、openwebui) 观察到模型返回了某种特殊的响应文本，客户端就执行模型响应文本中告知的插件，当然，客户端可以完全无视模型的特殊响应 一个简易的流程如下 ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:0:0","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["AI"],"content":"FunctionCall 以获取本地天气为例子 请求结构如下： 通过 functions 或 tools (最新的 functions 的别名) 告知了模型，当前客户端具备获取天气的能力 { \"messages\": [ { \"role\": \"system\", \"content\": \"You are a helpful assistant.\" }, { \"role\": \"user\", \"content\": \"今天上海天气怎么样？，湿度怎么样？\" } ], \"functions\": [ { \"name\": \"get_localtion_weather\", \"description\": \"get_localtion_weather，获取某个地点的当前天气情况\", \"parameters\": { \"type\": \"object\", \"properties\": { \"localtion\": { \"type\": \"string\", \"description\": \"localtion,地点\" }, \"need_humidity\":{ \"type\":\"boolean\", \"description\":\"是否返回湿度，默认为false\" } }, \"required\": [ \"localtion\" ] } } ], \"function_call\": \"auto\", \"temperature\": 0.5, \"stream\":false, \"model\": \"gpt-4o\" } curl --location 'https://api.xxxxx.com/v1/chat/completions' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer sk-xxxxx' \\ --data '{ \"messages\": [ { \"role\": \"system\", \"content\": \"You are a helpful assistant.\" }, { \"role\": \"user\", \"content\": \"今天上海天气怎么样？，湿度怎么样？\" } ], \"functions\": [ { \"name\": \"get_localtion_weather\", \"description\": \"get_localtion_weather，获取某个地点的当前天气情况\", \"parameters\": { \"type\": \"object\", \"properties\": { \"localtion\": { \"type\": \"string\", \"description\": \"localtion,地点\" }, \"need_humidity\":{ \"type\":\"boolean\", \"description\":\"是否返回湿度，默认为false\" } }, \"required\": [ \"localtion\" ] } } ], \"function_call\": \"auto\", \"temperature\": 0.5, \"stream\":false, \"model\": \"gpt-4o\" }' 响应结构如下： 客户端执行本地的 get_localtion_weather 函数 整体流程如图所示 (下图截取自 OpenAI 的文档，翻译来自沉浸式翻译) ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:1:0","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["AI"],"content":"MCP 简单理解：functionCall 是大家自己写自己的，没有一种统一的约定，而 MCP 是一种君子约定，mcpServer (查询天气插件) 遵循 MCP 协议开发，由 mcpClient (Cursor) 调用，原本需要自己写函数，现在变成了调用别人的库 MCP 重点在于 MCP 客户端 (Cherry Studio) 如何发现 MCP 服务端 (“插件”)、理解 “插件”具备的能力、调用“插件”、获取“插件”的响应结果 至于 将当前具备的插件功能发送到模型 (functions (别名 tools) 描述方式、提示词方式) MCP 客户端 (Cherry Studio) 如何根据模型的响应判断执行是否执行“插件”，执行那几个插件，则是客户端自己定义 MCP 客户端将插件执行结果返回给模型，也是可以自己定义 以下部分只是在应用领域领域，举例描述了结合MCP 对话流程，并没有对 MCP 这个“君子约定”做具体的详解 ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:2:0","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["AI"],"content":"Cherry Studio 举例 配置 mcpServers 如下，其中只有一个获取 和风天气 的 server 源自：HeFeng Weather MCP Server | Glama { \"mcpServers\": { \"hefeng-weather\": { \"isActive\": true, \"command\": \"npx\", \"args\": [ \"hefeng-mcp-weather@latest\", \"--apiKey=key-123132131321\" ] } } } 对话如下 查看本地拦截的第一次请求，可以发现是通过 tools 描述的方式，告诉模型，本地具备那些“插件”以及具备什么能力 { \"model\": \"gpt-4o\", \"messages\": [ { \"role\": \"user\", \"content\": \"今天上海天气怎么样？\" } ], \"temperature\": 0.7, \"max_tokens\": 2000, \"stream\": true, \"tools\": [ { \"type\": \"function\", \"function\": { \"name\": \"fd71edc4f65924613b9fd8330e78eb243\", \"description\": \"获取中国国内的天气预报\", \"parameters\": { \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"逗号分隔的经纬度信息 (e.g., 116.40,39.90)\" }, \"days\": { \"type\": \"string\", \"enum\": [ \"now\", \"24h\", \"72h\", \"168h\", \"3d\", \"7d\", \"10d\", \"15d\", \"30d\" ], \"description\": \"预报天数，now为实时天气，24h为24小时预报，72h为72小时预报，168h为168小时预报，3d为3天预报，以此类推\" } } } } } ] } 查看第一次响应，模型判断是否执行触发调用插件。 模型判断执行需要用到\"天气插件\"，模型本身只是做了判断 MCP 客户端 (Cherry Studio) 执行“天气插件”，可以简单看作调用了一个别人写好的包或API 将执行结果返回给模型，也就是加入对话上下文 { \"model\": \"gpt-4o\", \"messages\": [ { \"role\": \"user\", \"content\": \"今天上海天气怎么样？\" }, { \"role\": \"assistant\", \"tool_calls\": [ { \"id\": \"call_M4eYNv6oPaLunpZLe1iWdfiK\", \"function\": { \"name\": \"fd71edc4f65924613b9fd8330e78eb243\", \"arguments\": \"{\\\"days\\\":\\\"now\\\",\\\"location\\\":\\\"121,31\\\"}\" }, \"type\": \"function\" } ] }, { \"role\": \"tool\", \"content\": \"[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"地点: 121,31\\\\n观测时间: 2025-03-27T16:51+08:00\\\\n天气: 阴\\\\n温度: 13°C\\\\n体感温度: 12°C\\\\n风向: 东北风\\\\n风力: 1级\\\"}]\", \"tool_call_id\": \"call_M4eYNv6oPaLunpZLe1iWdfiK\" } ], \"temperature\": 0.7, \"max_tokens\": 2000, \"stream\": true, \"tools\": [ { \"type\": \"function\", \"function\": { \"name\": \"fd71edc4f65924613b9fd8330e78eb243\", \"description\": \"获取中国国内的天气预报\", \"parameters\": { \"type\": \"object\", \"properties\": { \"location\": { \"type\": \"string\", \"description\": \"逗号分隔的经纬度信息 (e.g., 116.40,39.90)\" }, \"days\": { \"type\": \"string\", \"enum\": [ \"now\", \"24h\", \"72h\", \"168h\", \"3d\", \"7d\", \"10d\", \"15d\", \"30d\" ], \"description\": \"预报天数，now为实时天气，24h为24小时预报，72h为72小时预报，168h为168小时预报，3d为3天预报，以此类推\" } } } } } ] } 模型结合上下文 (发送的对话历史) 进行响应 截取其中一部分 Cherry Studio 是通过 functionCall 的方式，判断应该执行那些“插件”的功能 ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:2:1","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["AI"],"content":"自定义协议 (使用系统提示词的方式) 你是一个智能助手，你具备MCP功能，MCP可以理解为一种本地功能插件，当用户的语句需要调用插件时，你应该严格按照以下规定返回，规定如下: \u003cplug\u003e \u003cpn\u003e插件名称\u003c/pn\u003e \u003cfn\u003e函数名称(功能名称)\u003c/fn\u003e \u003carg1\u003e参数\u003c/arg1\u003e \u003carg2\u003e参数2\u003carg2\u003e \u003carg3\u003e参数3\u003carg3\u003e \u003cplug/\u003e。 当本地执行了某插件后，结果回按照以下格式返回 \u003ctool_res\u003e \u003cplug\u003e \u003cpn\u003e插件名称\u003c/pn\u003e \u003cfn\u003e函数名称(功能名称)\u003c/fn\u003e \u003cres\u003e执行结果\u003cres/\u003e \u003cplug/\u003e \u003ctool_res/\u003e 当前本地插件: 1.插件名称：get_localtion_weather 描述：查询某个地点天气插件 功能： - query_now_weather: args: location:string,必需的,查询地点 need_humidity：boolean,非必需的，默认为false，是否返回湿度 图中所示为 ChatBox，其他的客户端会对 \u003cxx\u003e\u003cxx/\u003e 进行处理，显示不出来 ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:2:2","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["AI"],"content":"参考视频和链接🔗 MCP是怎么对接大模型的？抓取AI提示词，拆解MCP的底层原理_哔哩哔哩_bilibili 【大模型函数调用】function calling及自动发邮件案例_哔哩哔哩_bilibili 🫴手把手教你QwQ-32B如何玩转function call_哔哩哔哩_bilibili 7分钟讲清楚MCP是什么 ","date":"2025-04-02","objectID":"/mcpfunctioncall%E7%A7%91%E6%99%AE/:3:0","tags":["MCP/科普"],"title":"MCP、FunctionCall科普","uri":"/mcpfunctioncall%E7%A7%91%E6%99%AE/"},{"categories":["博客"],"content":"1. 介绍 这是我的第一篇博客，用来记录我的学习过程，以及一些想法。 ","date":"2025-04-01","objectID":"/first_post/:1:0","tags":["博客","学习","感想"],"title":"我的第一篇博客","uri":"/first_post/"},{"categories":["博客"],"content":"2. 感想 写博客是一种很好的学习方式，可以加深对知识的理解，同时也可以分享自己的心得体会。 ","date":"2025-04-01","objectID":"/first_post/:2:0","tags":["博客","学习","感想"],"title":"我的第一篇博客","uri":"/first_post/"},{"categories":["博客"],"content":"3. 总结 希望我的博客能够坚持下去，不断进步。 package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } ","date":"2025-04-01","objectID":"/first_post/:3:0","tags":["博客","学习","感想"],"title":"我的第一篇博客","uri":"/first_post/"},{"categories":null,"content":"关于我","date":"0001-01-01","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我 大家好,我是一名热爱技术和写作的程序员。这个博客主要用来记录我在学习和工作中的心得体会。 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"我的兴趣 编程开发 技术写作 开源项目 持续学习 ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"联系方式 如果你对我的文章有任何问题或建议,欢迎通过以下方式联系我: Email: your-email@example.com GitHub: your-github ","date":"0001-01-01","objectID":"/about/:1:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"博客 这个博客使用 Hugo 构建,主题是 LoveIt。我会在这里分享: 技术教程和笔记 项目开发经验 学习心得 生活随笔 希望能在这里结识更多志同道合的朋友。让我们一起交流,共同进步! ","date":"0001-01-01","objectID":"/about/:1:3","tags":null,"title":"关于","uri":"/about/"}]